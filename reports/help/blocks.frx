<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY nbsp "&#160;">
]>
<html xmlns:frx="urn:FrxReports">
<head>
<title>Building Custom Data Blocks</title>
<frx:category />
<frx:options hidden="1" />
<frx:parameters>
</frx:parameters>
<frx:docgen />
<frx:fields>
  <frx:field id="title" link="reports/{name}" />
  <frx:field id="role_report" link="reports/drupaladmin.role_detail">Roles</frx:field>
</frx:fields>
</head>
<body>
  <p>Custom data blocks are generally written as .sql files in a
    database repository. Below is the contents of the
    drupal/role_permissions data block that demonstrates role
    permissions.</p>
  <pre frx:renderer="FrxSource">
  --ACCESS=administer permissions
  SELECT * FROM {role_permission} p&nbsp;
    WHERE p.rid = :role
</pre>
  <p>The content of a data block is a SQL statement.&nbsp;</p>
  <h3>Security and data blocks&nbsp;</h3>
  <p>
    The line beginning with<strong>&nbsp;--ACCESS=<em>some_permission</em>
    </strong> is a required comment that indicates the permission required to
    access the data retrived by this block. The security for data block
    repository is configurable and pluggable, meaning that developers
    may create functions that determine how the permission is checked.
    In the drupal repository delivered with forena, access permissions
    are tested using the drupal user_access() function, so the value
    should match a drupal permission.
  </p>
  <p>In Drupal 7, drupal permissions passed to the user_access
    function are string keys that are usually lower cased versions of
    the rights found on the drupal permission tab. However, module and
    core developers may use any string that they want in creating
    rights. There is unfortunately no easy way in drupal to list module
    permissions, but after the permission has been granted to a role,
    you may use the {role_report} to determine</p>
  <h3>Parameters</h3>
  <p>
    The <strong>:role</strong> parameter in the example is named token
    that will be replaced in the SQL query with a parameter from the
    report. The parameter replacement is done by forena in a way that
    protects against SQL injection. Although these tokens are modeled
    after a commonly used database binding syntax, the replacement is
    done by Forena. Use this sytax instead of the native parameter
    binding for any database you are accessing with Forena. Tokens may
    be reference multiple times within the same SQL query.
  </p>
  <h3>Conditional SQL</h3>
  <p>When building data blocks you can specifcy sections of sql that
    are only included if a particular parameter is present. This lets
    you creqte SQL that has optional filters that can be of signifciant
    complexity and don't get included unless needed. The following
    example illustrates this technique</p>
  <pre>
  --ACCESS=access content
  SELECT * from states
  --IF=:state
  WHERE code=:state
  --ELSE
  WHERE code='AL'
  --END
  ORDER BY NAME
	</pre>
  <p>In the above example the Where clause is only added when there
    is a value specified for :state. If no value for :state is provided
    the WHERE clause limits the selection to code of 'AL'. The order by
    clause is always included.</p>
  <h3>Includes</h3>
  <p>Blocks can be build from other data blocks. To accomplish this
    use the --INCLUDE directive as follows:</p>
  <pre>
	--ACCESS=access content
	SELECT * FROM (
	--INCLUDE=users_by_state
	) t
	WHERE state=:state
	</pre>
  <p>Note that when icluding other data blocks you can only include
    blocks within the same repository, and that the security of the new
    datablock is the security that is used for that data. The --ACCESS
    line of the included block is ignored.</p>

  <ul id="forena-1" frx:block="forena_help/admin_topics">
    <li id="forena-2" frx:foreach="*"><span>{title}</span></li>
  </ul>
  <p>&nbsp;</p>
</body>
</html>
